思路：记下子树头结点的值，在源树中遍历寻找值相同的节点，调用check函数判断是否相等。
代码：有问题，未找到原因
class Solution {
public:
    bool isSubtree(TreeNode* s, TreeNode* t) {
        int key = t->val;
        TreeNode* p1 = s;
        TreeNode* p2 = NULL;
        bool res = false;
        while(p1){
            p2 = p1->left;
            if(p2){
                while(p2->right!=NULL && p2->right != p1) p2 = p2->right;
                if(p2->right == NULL){
                    p2->right = p1;
                    p1 = p1->left;
                    continue;
                }else{
                    p2->right = NULL;
                }
            }
            if(p1->val == key) {
                res = checkissubtree(p1,t);
                if(res) return true;
                //return true;
            } 
            p1 = p1->right;
        }
       return res;
    }
    bool checkissubtree(TreeNode* origin,TreeNode* newtree){
        if(origin == NULL && newtree == NULL) return true;
        if(origin == NULL || newtree == NULL) return false;
        if(origin->val == newtree->val){
            return checkissubtree(origin->left,newtree->left) && checkissubtree(origin->right,newtree->right); 
        }else{
            return false;
        }
    }
};

代码：换一种遍历方式 
22ms 26ms 大多数，较快
class Solution {
public:
    bool isSubtree(TreeNode* s, TreeNode* t) {
        if(s == NULL && t == NULL) return true;
        if(s == NULL || t == NULL) return false;
        int key = t->val;
        stack<TreeNode*> sta;
        bool res = false;
        while(s || !sta.empty()){
            if(s){
                if(s->val == key){
                    res = checkissubtree(s,t);
                    if(res) return true;
                }
                sta.push(s->right);
                s = s->left;
            }else{
                    s = sta.top();
                    sta.pop();
            }
        }
        return res;
    }
    bool checkissubtree(TreeNode* origin,TreeNode* newtree){
        if(origin == NULL && newtree == NULL) return true;
        if(origin == NULL || newtree == NULL) return false;
        if(origin->val == newtree->val){
            return checkissubtree(origin->left,newtree->left) && checkissubtree(origin->right,newtree->right); 
        }else{
            return false;
        }
    }
};
